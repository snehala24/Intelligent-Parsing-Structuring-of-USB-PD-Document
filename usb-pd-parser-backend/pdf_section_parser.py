"""
pdf_section_parser.py
---------------------
Parses each section in the USB PD Specification PDF based on TOC entries,
structures them in JSONL format (usb_pd_spec.jsonl).
Requires: pdfplumber, tqdm
Note: Assumes usb_pd_toc.jsonl already generated by pdf_toc_parser.py
"""
import pdfplumber
import json
import re
from tqdm import tqdm

def read_toc_jsonl(toc_filename):
    """Load TOC entries from JSONL file"""
    toc = []
    try:
        with open(toc_filename, 'r', encoding='utf-8') as f:
            for line in f:
                if line.strip():
                    toc.append(json.loads(line))
    except FileNotFoundError:
        print(f"Error: {toc_filename} not found")
        return []
    except json.JSONDecodeError as e:
        print(f"Error parsing JSON in {toc_filename}: {e}")
        return []
    
    # Sort by page number to ensure proper order
    toc.sort(key=lambda x: (x.get('page', 0), x.get('section_id', '')))
    return toc

def clean_content(text):
    """Clean extracted text content"""
    if not text:
        return ""
    
    # Remove excessive whitespace
    text = re.sub(r'\n\s*\n\s*\n', '\n\n', text)
    # Remove page headers/footers (common patterns)
    text = re.sub(r'Universal Serial Bus Power Delivery Specification.*?\n', '', text)
    text = re.sub(r'Page \d+.*?\n', '', text)
    
    return text.strip()

def extract_sections(pdf_path, toc):
    """Extract section content based on TOC entries"""
    sections = []
    
    try:
        with pdfplumber.open(pdf_path) as pdf:
            total_pages = len(pdf.pages)
            
            for i, toc_entry in enumerate(tqdm(toc, desc="Parsing sections")):
                start_page = max(0, toc_entry['page'] - 1)  # pdfplumber zero-based
                
                # Determine end page for this section
                if i + 1 < len(toc):
                    end_page = min(toc[i + 1]['page'] - 1, total_pages)
                else:
                    end_page = total_pages
                
                # Extract content from page range
                section_text = ""
                for page_idx in range(start_page, end_page):
                    if page_idx < total_pages:
                        page_text = pdf.pages[page_idx].extract_text() or ''
                        section_text += page_text + '\n'
                
                # Clean and prepare the entry
                entry = toc_entry.copy()
                entry['content'] = clean_content(section_text)
                sections.append(entry)
                
    except Exception as e:
        print(f"Error processing PDF: {e}")
        return []
    
    return sections

def validate_sections(sections):
    """Basic validation of extracted sections"""
    valid_sections = []
    issues = []
    
    for section in sections:
        # Check required fields
        required_fields = ['doc_title', 'section_id', 'title', 'full_path', 'page', 'level', 'parent_id', 'tags', 'content']
        missing_fields = [field for field in required_fields if field not in section]
        
        if missing_fields:
            issues.append(f"Section {section.get('section_id', 'unknown')}: missing fields {missing_fields}")
            continue
            
        # Check data types
        if not isinstance(section['page'], int) or section['page'] < 1:
            issues.append(f"Section {section['section_id']}: invalid page number")
            
        if not isinstance(section['level'], int) or section['level'] < 1:
            issues.append(f"Section {section['section_id']}: invalid level")
            
        valid_sections.append(section)
    
    if issues:
        print("Validation issues found:")
        for issue in issues[:10]:  # Show first 10 issues
            print(f"  - {issue}")
        if len(issues) > 10:
            print(f"  ... and {len(issues) - 10} more issues")
    
    return valid_sections

if __name__ == '__main__':
    import sys
    
    if len(sys.argv) < 2:
        print("Usage: python pdf_section_parser.py <pdf_file> [toc_file]")
        sys.exit(1)
    
    pdf_file = sys.argv[1]
    toc_file = sys.argv[2] if len(sys.argv) > 2 else 'usb_pd_toc.jsonl'
    
    print(f"Loading TOC from {toc_file}...")
    toc_entries = read_toc_jsonl(toc_file)
    
    if not toc_entries:
        print("No TOC entries found. Exiting.")
        sys.exit(1)
    
    print(f"Extracting {len(toc_entries)} sections from {pdf_file}...")
    sections = extract_sections(pdf_file, toc_entries)
    
    print("Validating sections...")
    valid_sections = validate_sections(sections)
    
    # Save to JSONL
    output_file = 'usb_pd_spec.jsonl'
    with open(output_file, 'w', encoding='utf-8') as f:
        for obj in valid_sections:
            f.write(json.dumps(obj, ensure_ascii=False) + '\n')
    
    print(f"âœ… Parsed {len(valid_sections)} sections to '{output_file}'.")
    
    # Generate metadata
    metadata = {
        "doc_title": valid_sections[0]['doc_title'] if valid_sections else "Unknown",
        "total_sections": len(valid_sections),
        "avg_content_length": sum(len(s['content']) for s in valid_sections) / len(valid_sections) if valid_sections else 0,
        "sections_with_content": sum(1 for s in valid_sections if s['content'].strip()),
        "processing_date": str(pd.Timestamp.now()) if 'pd' in globals() else "unknown"
    }
    
    with open('usb_pd_metadata.jsonl', 'w', encoding='utf-8') as f:
        f.write(json.dumps(metadata, ensure_ascii=False) + '\n')
    
    print(f"ðŸ“Š Metadata saved to usb_pd_metadata.jsonl")